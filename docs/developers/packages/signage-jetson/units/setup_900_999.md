# setup(900-999)

## **900_extlinux.sh**

このスクリプトは、Jetson の `extlinux.conf` に **quiet / splash / loglevel=3 / vt.global_cursor_default=0 / console=tty3** を付与し、  
起動時のコンソール出力を抑制してサイネージ画面をクリーンにします。  
**Raspberry Pi は自動スキップ**（`BOARD_TYPE` に `pi`/`rasp` を含む）。

> 処理の流れ

1) **Raspberry Pi 判定**：`BOARD_TYPE` に `pi`/`rasp` を含む場合は **スキップ**  

2) **必須変数チェック**：`EXT_LINUX_CONF_FILE` 未設定ならエラー終了  

3) **ファイル存在チェック**：見つからなければ **警告して終了**（ノーチェンジ）  

4) **トークン付与ロジック**  
   - `console=tty0` があれば **`console=tty3` に置換**。無ければ **`console=tty3` を追加**  
   - `quiet` / `splash` / `loglevel=3` / `vt.global_cursor_default=0` を **APPEND 行に追加**（重複は追加しない）  
   - 追加は `rootfstype=ext4` を含む `APPEND` 行を基準に `sed` で付与

!!! warning "フォーマット差異への注意"
    付与ロジックは `rootfstype=ext4` を含む `APPEND` 行を前提にしています。  
    もし `btrfs` やカスタム書式等でマッチしない場合は、スクリプトの `sed` パターン調整が必要です。

---

## **910_raspi_splash.sh**

**Raspberry Pi 専用**の起動見た目チューニング用スクリプト。  
GPU ファームウェアの虹色スプラッシュを **無効化** し、Linux カーネルの起動ログを **静音化** します。  

> 処理の流れ）

1) **ボード判定**  
   `BOARD_TYPE` を小文字化し、`pi`/`rasp` を含まなければ **スキップ**。

2) **config.txt に虹色スプラッシュ無効を追記**  
   `/boot/firmware/config.txt` があれば、`disable_splash=1` を **未設定時のみ追記**。

3) **cmdline.txt にカーネル静音パラメータを付与**  
   `/boot/firmware/cmdline.txt` があれば、現行 1 行を読み出し、  
   `quiet` / `loglevel=3` / `logo.nologo` を **不足分だけ末尾に追記**し、上書き保存。

!!! tip "静音レベルの調整"
    さらに静かにしたい場合は `systemd.show_status=false` を `cmdline.txt` に追加します。  
    逆にデバッグ時は `quiet` を外し、`loglevel=7` に上げると詳細ログを表示できます。

---

## **950_auto_x.sh**

このスクリプトは、`tty1` に自動ログイン → `~/.bash_profile` で `startx` → `~/.xinitrc` から **Openbox + Chromium キオスク** を起動する設定を行います。  
**Jetson** では Xorg の回転・解像度を `10-nvidia-rotate.conf` で設定、**Raspberry Pi** では `config.txt` に KMS オーバーレイ等を追記します。  
最後に **GDM を無効化**し、既定ターゲットを `multi-user.target` に切り替えます。

| 変数/引数                         | 例                                                            | 説明                           |
| ----------------------------- | ------------------------------------------------------------ | ---------------------------- |
| `XORG_CONF_DIR` / `FILE`      | `/etc/X11/xorg.conf.d` / `10-nvidia-rotate.conf`             | Jetson 用の Xorg 設定配置          |
| `DISPLAY_OUTPUT`              | `HDMI-1`                                                     | `xrandr` の出力名                |
| `DISPLAY_RESOLUTION`          | `1920x1080`                                                  | 画面解像度                        |
| `DISPLAY_ROTATION`            | `left`                                                       | `normal/left/right/inverted` |
| `FIRMWARE_CONFIG_FILE`        | `/boot/firmware/config.txt`                                  | Pi のファームウェア設定                |
| `KMS_OVERLAY` / `FB_LINE`     | `dtoverlay=vc4-kms-v3d` / `framebuffer_width=…`              | Pi の表示関連追記                   |
| `AUTOLOGIN_USER`              | `$USERNAME`                                                  | `.xinitrc` の所有者設定に使用         |

> 処理の流れ

1) **getty オーバーライドで自動ログイン**  
   `/etc/systemd/system/getty@tty1.service.d/override.conf` を作成 → `daemon-reload` → `restart getty@tty1`。

2) **`~/.bash_profile` で `tty1` ログイン時に `startx`**  
   `if [ -z "$DISPLAY" ] && [ "$(tty)" = "/dev/tty1" ]; then startx; logout; fi` を記述。

3) **空カーソル XBM の配置**  
   `~/.config/cursors/blank.xbm`, `blank_mask.xbm` を生成（1×1）。

4) **ボード別グラフィック調整**  
   - **Jetson:** `${XORG_CONF_DIR}/${XORG_CONF_FILE}` を作成し、`metamodes` で出力・解像度・回転を指定。  
   - **Raspberry Pi:** `${FIRMWARE_CONFIG_FILE}` に `dtoverlay` と `framebuffer_*` を未設定時のみ追記。

5) **`~/.xinitrc` を生成（Openbox + Chromium キオスク）**  
   `unclutter` 起動 → `openbox` 起動 → `xset -dpms; xset s off; xset s noblank` →  
   ループで `chromium(--browser)` を `--kiosk` で `http://127.0.0.1:3000/welcome.html` を表示（`/tmp/UPDATING` があれば待機）。

6) **GDM 無効化 & 既定ターゲット切替**  
   `systemctl disable --now gdm3`（存在時） → `systemctl set-default multi-user.target`。

!!! warning "セキュリティ（自動ログイン）"
    自動ログインは **物理アクセスで誰でもログイン可能** になります。  
    公開環境では **筐体ロック・ネットワーク制御・不要サービス停止** を必ず行ってください。

!!! tip "出力名/回転の調整（Jetson）"
    `DISPLAY_OUTPUT` は実機で `xrandr -q` により確認してください（例: `HDMI-0`, `DP-0`）。  
    回転は `normal` / `left` / `right` / `inverted` が指定可能です。

!!! note "Chromium のコマンド"
    ディストリによりバイナリ名が `chromium-browser` / `chromium` で異なります。  
    本スクリプトは両方を探索します。`--user-data-dir=/tmp/...` は **揮発プロファイル** です。永続化したい場合は専用ディレクトリを指定してください。

!!! warning "Pi の KMS 設定"
    `dtoverlay=vc4-kms-v3d` は **KMS ドライバ** 前提です。`fkms` と混在させないでください。  
    既存の `dtoverlay=vc4-fkms-v3d` がある場合は **置き換え** を検討してください。

---

## **960_setup_pulse.sh**

このスクリプトは、`BOARD_TYPE` に応じて **HDMI の sink 名** を選び、PulseAudio 設定に  
`set-default-sink <SINK_NAME>` を **追記**してデフォルト出力を HDMI に固定します。  
Jetson / Raspberry Pi 以外は **エラー終了**。

> 処理の流れ

1) **ボード判定と sink 名の決定**  
   - Jetson → `set-default-sink alsa_output.platform-3510000.hda.hdmi-stereo`  
   - Raspberry Pi → `set-default-sink alsa_output.platform-fef00700.hdmi.iec958-stereo`  
   - それ以外 → **エラーで中断**  

2) **設定ファイルへ追記**  
   - `${PULSE_DIR}` を作成し、`${PULSE_CONF_FILE}` に `set-default-sink <決定したSINK>` を追記（append）  
   - 所有者/権限：`root:root` / `644`  

3) **（必要なら）音声デーモン再起動**  
`systemctl --user restart pulseaudio` または `systemctl --user restart pipewire-pulse`

!!! note "sink 名は環境差があります"
    カーネル/デバイス/JetPack 版によって **sink 名が異なる** 場合があります。  
    `pactl list short sinks` で実機の sink 名を確認し、スクリプト内の定数を適宜調整してください。  
    複数 HDMI（例: `HDMI-0/HDMI-1`）がある環境では目的のポートに対応する sink を選択してください。

!!! warning "PipeWire 環境の注意"
    `pipewire-pulse` を使用している場合、**PulseAudio の .pa 追記が反映されない** ことがあります。  
    その場合は一時的に `wpctl set-default <ID|NAME>` で既定を切り替えるか、WirePlumber の設定で永続化を検討してください。

!!! tip "重複追記のケア"
    本スクリプトは **追記（append）** 方式です。再実行で同じ行が増えることがあります。  
    運用で冪等性が必要な場合は、既存行の有無を確認してから追記するロジックに調整してください。

---

## **964_pi_bootloader_power_cfg.sh**

このスクリプトは、**Raspberry Pi 専用**。ブートローダ設定で  

- `POWER_OFF_ON_HALT=1`（`halt` 時に **電源断**）  
- `WAKE_ON_GPIO=1`（GPIO からの **ウェイク**）  
を有効化します。既に両方が有効なら **スキップ**。

> 処理の流れ

1) **現在設定の確認**  
   `vcgencmd bootloader_config` に `POWER_OFF_ON_HALT=1` と `WAKE_ON_GPIO=1` が **両方あれば即終了**。  

2) **EEPROM .bin を特定**  
   `rpi-eeprom-update -d` の `CURRENT:` から `pieeprom-*.bin` を取得。見つからない場合は `RELEASE:` ディレクトリ内の **最新** `pieeprom-*.bin` を選択。  

3) **一時設定ファイルを生成**  
   `POWER_OFF_ON_HALT=1`, `WAKE_ON_GPIO=1`

4) **設定を .bin に適用してステージング**  
   `rpi-eeprom-config --apply <tmp_cfg> <cur_bin>` を実行。

5) **完了マーカー作成**  
   `/etc/pi_bootloader_power_cfg.done` を作成。

!!! note "モデル/ファーム差異"
    本設定の有効性や挙動は **Raspberry Pi のモデル/ブートローダ（EEPROM）版** に依存します。  
    環境によっては `vcgencmd bootloader_config` の値が **再起動後に反映** されます。

!!! tip "手動検証のヒント"
    フラッシュ前に適用内容を確認するには、**別出力を作って差分確認** する運用も可能です。  

---

## **967_pi_power_off_gpio18.sh**

**Raspberry Pi 専用**。電源制御回路向けに **GPIO18（BCM 18）を High に上げてから電源断**する Python スクリプトを配置し、  
それを実行する **systemd oneshot サービス**（`pi-poweroff.service`）を作成します。  
`BOARD_TYPE` に `rasp`/`pi` を含まない場合は **スキップ**します。

| 変数/引数               | 例                                                                  | 説明                            |
| ------------------- | ------------------------------------------------------------------ | ----------------------------- |
| `SRC_PY` / `DST_PY` | `scripts/power/pi_power_off.py` / `/usr/local/bin/pi_power_off.py` | Python スクリプトの配置元/先            |
| `UNIT_FILE`         | `/etc/systemd/system/pi-poweroff.service`                          | 作成する unit のパス                 |

> 処理の流れ

1) **Pi 判定**  
   `BOARD_TYPE` を小文字化し、`rasp` / `pi` を含まなければ **スキップ**。  

2) **パス定義**  
   `SRC_PY`（配置元）、`DST_PY`（配置先）、`UNIT_FILE`（ユニットパス）を設定。  

3) **Python スクリプト配置**  
   `install_or_link "$SRC_PY" "$DST_PY"` で **冪等配置**（開発中はシンボリックリンクの可能性）。  

4) **systemd ユニット作成**  
   `pi-poweroff.service` を `${UNIT_FILE}` に生成。**ユニット内容は本ドキュメントでは省略し、ソースを参照**（`scripts/setup/980_rpi_gpio_poweroff.sh` / `${UNIT_FILE}`）。  

!!! warning "危険：手動起動は電源が落ちる可能性"
    `pi-poweroff.service` を `start` すると **即時に GPIO18 を High にし、電源断動作へ移行**する実装である可能性があります。  
    **必ず安全なテスト環境**（現地作業・シリアル接続など）で実施し、遠隔作業時のロックアウトに注意してください。

!!! note "代替手段：`gpio-poweroff` オーバレイ"
    Raspberry Pi では `config.txt` に  
    `dtoverlay=gpio-poweroff,gpiopin=18,active_low=0`  
    のような **デバイスツリー・オーバレイ**で電源断時のピン制御を自動化できます。Python 依存が不要で **堅牢** です（要件に応じて選択）。

---

## **980_sudo_power.sh**

このスクリプトは、ユーザー `${USERNAME}` に対して、以下コマンドを **パスワードなし（NOPASSWD）で sudo 実行**できるよう  
`/etc/sudoers.d/` にドロップインを作成します。作成後に **visudo で構文チェック**を行います。

- `/sbin/poweroff`, `/sbin/reboot`
- `/usr/bin/sed`, `/usr/bin/pkill`

> 処理の流れ

1) **sudoers ドロップインを作成**  
   - `/etc/sudoers.d/${USERNAME}-power`
   - `/etc/sudoers.d/${USERNAME}-rotate`

2) **権限/所有者を設定**（`mode 440`、`root:root`）  

3) **構文チェック**（`visudo -c` で各ファイルを検証）  

!!! warning "権限付与のリスク（最小権限の原則）"
    `NOPASSWD` で広くコマンドを許可すると、**想定外の操作**に悪用される恐れがあります。  
    可能なら **ラッパースクリプト**（特定の引数/対象のみ許可）を作成し、**そのスクリプトだけ** を sudoers に登録してください。

!!! note "インクルードの有効化"
    `/etc/sudoers` に `#includedir /etc/sudoers.d` が必要です。  
    ない場合は **必ず `visudo` 経由**で追記して、有効化してください。

!!! tip "パスの差異に注意"
    ディストリ/バージョンによりコマンドの **フルパス** が異なることがあります（例: `/sbin/poweroff` ↔ `/usr/sbin/poweroff`）。  
    `command -v poweroff reboot sed pkill` で実機のパスを確認し、sudoers の記述を **実際のパスに合わせて** 調整してください。

---

## **981_sudo_signage_update.sh**

このスクリプトは、ユーザー `${USERNAME}` に対し、**パスワード無し（NOPASSWD）**で以下を実行できるよう  
`/etc/sudoers.d/${USERNAME}-signage-update` を作成します。

- `systemctl start/stop/restart signage-update.service`
- `ln`, `chmod`

> 処理の流れ

1) **sudoers ドロップインを作成**（`${USERNAME}-signage-update`）。  

2) **権限設定**：作成ファイルに `chmod 440`（所有者は root:root）。  

3) **構文チェック**：`visudo -cf "/etc/sudoers.d/${USERNAME}-signage-update"` を実行。

!!! warning "権限は最小化を徹底（ラッパー推奨）"
    `ln`/`chmod` を広く NOPASSWD で許可すると **想定外の操作** を招きます。  
    可能なら **引数を制限したラッパースクリプト** を用意し、sudoers には **そのスクリプトのみ** を登録してください。  
    `systemctl` も対象サービスを **signage-update.service に限定**した現状を維持してください。

!!! tip "パスの差異に注意（systemctl の場所）"
    ディストリ/版により `systemctl` のパスが `/bin/systemctl` または `/usr/bin/systemctl` です。  
    sudoers は **フルパス一致** なので、`command -v systemctl` で実機のパスを確認して記述を調整してください。

!!! note "ロールバック"
    付与を戻すには `sudo rm /etc/sudoers.d/${USERNAME}-signage-update` を実行し、  
    その後 `sudo visudo -c` で **構文検証**を行ってください。

---

## **982_sudo_wifi_reset.sh**

このスクリプトは、ユーザー `${USERNAME}` に対し、**パスワード無し（NOPASSWD）**で以下のコマンド実行を許可する sudoers ドロップインを作成します。  
対象: `wpa_cli`, `chmod`, `reboot`（Wi-Fi 再接続や権限修正、必要時の再起動に利用）

> 処理の流れ

1) **sudoers ドロップインを作成**（`${USERNAME}-wifi-reset`）。  

2) **権限/所有者を設定**（`chmod 440`、`root:root`）。  

3) **構文チェック**（`visudo -cf "/etc/sudoers.d/${USERNAME}-wifi-reset"`）。

!!! warning "権限付与のリスク（最小権限の原則）"
    `wpa_cli` や `reboot` を広く NOPASSWD で許可すると **想定外の無線設定変更/再起動** が可能になります。  
    可能であれば **引数を固定したラッパースクリプト**（例: `wpa_cli -i wlan0 reconfigure` のみ）を用意し、  
    sudoers には **そのラッパーのみ** を登録してください。

!!! tip "パスの差異に注意"
    sudoers は **フルパス一致** で評価されます。ディストリによっては  
    `wpa_cli`（例: `/usr/bin/wpa_cli` / `/sbin/wpa_cli`）、`reboot`（例: `/usr/sbin/reboot` / `/sbin/reboot`）の  
    位置が異なるため、`command -v wpa_cli reboot chmod` で実機のパスを確認し、記述を合わせてください。

!!! note "ロールバック"
    付与を戻すには `sudo rm /etc/sudoers.d/${USERNAME}-wifi-reset` を実行し、  
    続けて `sudo visudo -c` で **構文検証** を行ってください。

---

## **999_patch_marker.sh**

このスクリプトは、`PATCH_DIR` 内の `*.sh` を **辞書順で最後の 1 件** として抽出し、その **ベース名** を `PATCH_MARK` ファイルに書き込みます。  
`PATCH_MARK` は `root:root / 644` に設定され、**参照側が「最後に適用されたパッチ名」を取得**するために使用されます。

> 処理の流れ

1) `PATCH_DIR` 直下の `*.sh` を検索し、**辞書順の最後の 1 件**を取得。  

2) 取得したパスから **ベース名** を抽出（`BASENAME=${LATEST##*/}`）。  

3) `PATCH_MARK` に **ベース名を 1 行で書き込み**、`root:root` / `644` を設定。

!!! note "空ファイルの扱い"
    パッチが 1 件も無い場合は `LATEST` が空となり、`PATCH_MARK` の内容も **空行** になります。  
    参照側は **未設定（空）を有効な状態として扱う** 実装にしてください。
