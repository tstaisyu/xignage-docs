# setup(100-199)

## **100_install_node.sh**

このスクリプトは、既存の Node.js を削除して **Nodesource** から指定バージョン（`$NODE_VERSION`）を導入し、**signage-server** の最新リリースと **signage-admin-ui** を GitHub Releases から取得・検証（SHA256）・設置します。サーバはタイムスタンプ付きの `releases/<YYYYmmdd_HHMMSS>` に展開し、`current` シンボリックリンクを新リリースへ更新します。  
`$NODE_VERSION` が見つからない場合は **20.x にフォールバック**します。

> 処理の流れ

1) **既存 Node.js の削除**  

2) **Node.js の導入**  

3) **signage-server ディレクトリの準備**  
   - `"$SIGNAGE_CORE_DIR"` に対して `chown -R "$USERNAME:$USERNAME"` / `chmod -R 755`

4) **signage-server の最新リリース取得・展開**  
   - API: `https://api.github.com/repos/tstaisyu/signage-server/releases/latest`  
   - 取得アセット: `signage-server.tar.gz` / `signage-server.tar.gz.sha256`  
   - `sha256sum -c` で検証 → `releases/<TIMESTAMP>` に展開 → `npm ci --omit=dev --ignore-scripts`  
   - `current` を新リリースへ `ln -sfn` → 新リリースを `chown -R "$USERNAME:$USERNAME"`

5) **signage-admin-ui の最新リリース取得・展開**  
   - API: `https://api.github.com/repos/tstaisyu/signage-admin-ui/releases/latest`  
   - 取得アセット: `admin-ui.tar.gz` / `admin-ui.tar.gz.sha256`  
   - 既存の `$ADMIN_UI_DIR` を削除→再作成→展開→`chown -R "$USERNAME:$USERNAME"`

6) **設定完了後、tmp/の一時ファイルを削除**

!!! 注意
    `npm ci --ignore-scripts`: postinstall 等のスクリプトは実行されません。必要な場合は運用方針に応じて外してください。

---

## **101_install_edge_detection.sh**

このスクリプトは、**Raspberry Pi 以外**の環境で、`xignage-edge-detection` の最新リリースを **GitHub Releases から取得→検証（SHA256）→展開→`current` 切替**まで自動実行します。  
`/etc/nv_tegra_release` ではなく **BOARD_TYPE による判定**で、`rasp` / `pi` を含む場合は **安全にスキップ**します。

> 処理の流れ

1) **Raspberry Pi 判定**  
   `BOARD_TYPE` に `rasp` / `pi` を含む場合は **スキップ**。

2) **releases & staging ディレクトリの準備**  
   `releases/<TIMESTAMP>` を作成し、以後の展開先を **staging** として利用。

3) **xignage-edge-detection の最新リリース取得・展開**  
   - API: `https://api.github.com/repos/tstaisyu/xignage-edge-detection/releases/latest`
   - 取得アセット: `xignage-edge-detection.tar.gz` / `xignage-edge-detection.tar.gz.sha256` で検証 → `releases/<TIMESTAMP>` に展開
   - `current` を新リリースへ `ln -sfn` → 新リリースを `chown -R "$USERNAME:$USERNAME"`  

4) **設定完了後、tmp/の一時ファイルを削除**

5) **（任意）Python 依存パッケージのインストール**  
   `requirements-full.txt` があれば `pip3 install -r` を実行。

---

## **105_install_metrics_service.sh**

このスクリプトは、`xignage-metrics`（デバイス指標を MQTT 等へ送信する Node.js アプリ）を**配置・依存導入・サービス常駐化**します。  
主な処理は以下のとおりです。

1) アプリコードを **rsync（--delete）** で `METRICS_SRC → METRICS_DST` に同期

2) 状態保存用ディレクトリ **`/var/lib/xignage-metrics`** を作成（`700`）

3) **本番依存**を `npm ci --omit=dev` で導入

4) **環境変数ファイル** `/etc/signage/metrics.env` を未存在時にサンプルから `600` で配置

5) **systemd ユニット** `/etc/systemd/system/xignage-metrics.service` を生成し **有効化 & 起動**

!!! note
    `metrics.env` には MQTT 接続情報など秘密情報を記載します（自動生成は **未** 編集のサンプル配置のみ）。

!!! warning
    初回実行後は `/etc/signage/metrics.env` を編集して資格情報を設定してください。

---

## **106_install_call_button_service.sh**

**呼び鈴（インターホン）ボタン常駐デーモン**を導入し、`call-button.service` を作成・起動します。  
Raspberry Pi / Jetson の双方で動作（Python 側で GPIO ライブラリを自動選択）。プルアップ構成の**物理ピン11（既定）**をデバウンス処理し、  
**状態スナップショット**を `/run/signage/io_state.json` に原子的に書き込み、**イベント**を `/var/log/signage/io_events.jsonl` へ **JSON Lines** で追記します。

- 実行環境：`bash` ≥ 4、`systemd`、`python3`
- 依存：`scripts/lib/config.sh`（`USERNAME`・`LOG_FILE` 等）、`scripts/lib/functions.sh`（`install_or_link`）
- 既定の環境変数ファイル：`/etc/signage/io.env`（存在しなければ本スクリプトが生成）

> 生成／変更されるもの  

- **実行ファイル群（/opt/local/bin）**
  - `/opt/local/bin/app.py`（エントリポイント・実行ビット付与）
  - `/opt/local/bin/button.py`（ローカルモジュール）
  - `/opt/local/bin/tof.py`（ToF オプション用モジュール）
  - `/opt/local/bin/aws_iot_pub.py`（AWS IoT 送信用モジュール／`events.env` の `EVENTS_*` を参照）
  - 配置方法：`install_or_link`（**リンク or コピー**で冪等設置）
  - 所有者：`${USERNAME}:${USERNAME}`（`config.sh` に準拠）
- **環境変数ファイル**
  - `/etc/signage/io.env`（無ければデフォルトを書き込み／`0644`）
- **ログディレクトリ**
  - `/var/log/signage`（`${USERNAME}` 所有、`0755`）
- **systemd ユニット**
  - `/etc/systemd/system/call-button.service`
  - `systemctl daemon-reload && systemctl enable --now call-button.service`

### `/etc/signage/io.env`（既定・抜粋）

```dotenv
BUTTON_BOARD_PIN=11
BUTTON_DEBOUNCE_MS=30
STATE_PATH=/run/signage/io_state.json
EVENTS_PATH=/var/log/signage/io_events.jsonl
# ToF (optional)
# TOF_ENABLE=1
# TOF_MODEL=auto           # auto|vl53l0x|vl53l1x|none
# TOF_ADDR=0x29
# TOF_BUS=1
# TOF_THRESHOLD_MM=1200
# TOF_DISTANCE_MODE=2      # 0/1/2 = SHORT/MEDIUM/LONG
# TOF_TIMING_BUDGET_MS=50
```

### systemd ユニット（要点）

- **User/Group**：`${USERNAME}` 実行（GPIO / I2C へのアクセス前提）
- **EnvironmentFile**：`/etc/signage/io.env` と（任意の）`/etc/signage/events.env` を読み込み
- **RuntimeDirectory=signage**（`/run/signage` を systemd 側で用意）
- **ハードニング**：`NoNewPrivileges=true`, `ProtectSystem=full`, `ProtectHome=true`, `PrivateTmp=true`  
  （GPIO/I2C 要件に応じて調整可）

!!! warning "GPIO ピンとプルアップ構成"
    既定の `BUTTON_BOARD_PIN=11`（物理ピン 11）は **BOARD 番号**です（BCM とは異なる番号体系）。  
    Python 側の入力モード設定・プルアップ/プルダウン指定が**ハード配線と一致**していることを確認してください。

!!! note "ToF の利用（任意）"
    ToF を使う場合は上記 `TOF_*` を有効化。使用ドライバ（`vl53l0x`/`vl53l1x`）に応じて Python 依存を追加してください。

!!! tip "権限まわり"
    `/var/log/signage` は `${USERNAME}` 所有、`/run/signage` はユニットの `RuntimeDirectory` で作成されます。  
    権限エラーが出る場合はユニットの `User/Group` とディレクトリ所有を確認してください。

---

## **110_write_iot_certs_and_env.sh**

このスクリプトは、AWS IoT 用の **X.509 証明書 3 点**（`cert.pem`, `private.key`, `AmazonRootCA1.pem`）を安全な権限で所定パスへ配置し、`/etc/signage/metrics.env` に **IoT 接続設定（ENDPOINT と証明書パス）を追記/更新**、稼働中なら **xignage-metrics サービスを再起動**して反映します。  

> 前提条件

1) 事前に `/tmp/certs/` に以下のファイルがあること：  
  `cert.pem`（デバイス証明書）  
  `private.key`（秘密鍵）  
  `AmazonRootCA1.pem`（ルートCA）  

2) 環境変数：  
  `IOT_ENDPOINT`（例：`a1b2c3d4e5-ats.iot.ap-northeast-1.amazonaws.com`）

3) 主要パス（スクリプト内定義）：  
   証明書コピー元：`/tmp/certs`（`CERT_SRC`）  
   証明書配置先：`/etc/signage/certs`（`CERT_DST`）  
   環境ファイル：`/etc/signage/metrics.env`（`ENV_FILE`）  
   対象サービス：`xignage-metrics.service`（`SERVICE`）  

> 処理の流れ

1) **証明書を安全に配置（冪等）**  
   - 先に `CERT_DST` を `700` で作成  
   - 各ファイルは **差分がある場合のみ** `600` で上書き（`cmp -s` で比較）

2) **`metrics.env` をキー単位で更新（冪等）**  
   - 一時ファイルに編集後、差分があればバックアップ作成 → `install -m600` で置換  
   - 追記/更新されるキー：
     - `IOT_ENDPOINT`（環境変数の値）
     - `IOT_CERT_PATH=/etc/signage/certs/cert.pem`
     - `IOT_KEY_PATH=/etc/signage/certs/private.key`
     - `IOT_CA_PATH=/etc/signage/certs/AmazonRootCA1.pem`

!!! note "注意"
    - `入力検証`: **IOT_ENDPOINT** が未設定だと **metrics.env** に空値が書き込まれる可能性があります。実行前に必ず設定してください。

---

## **111_write_events_iot_env.sh**

**目的**：イベント送信用の **AWS IoT 接続情報**と **証明書**を端末へ安全配置し、`/etc/signage/events.env` を生成します。  
`call-button.service`（インターホン常駐）を検出した場合は **daemon-reload + restart** を実行（冪等）。

- 参照ファイル：
  - `/etc/signage/signage.env` … **DEVICE_ID** を取得
  - `/etc/signage/metrics.env` … **IOT_ENDPOINT** を取得
  - `/tmp/events-certs/{cert.pem, private.key, AmazonRootCA1.pem}` … 事前配布済みの証明書群
- 生成ファイル：
  - `/etc/signage/events.env` … イベント送信で参照される **AWS_IOT_ENDPOINT / EVENTS_\*** を定義
  - `/etc/signage/events-certs/<DEVICE_ID>/` … 証明書一式を格納（`700` ディレクトリ、`600` ファイル）

> 生成／変更されるもの

- **証明書ストア**
  - 置き場所：`/etc/signage/events-certs/<DEVICE_ID>/`
  - 内容：`cert.pem`, `private.key`, `AmazonRootCA1.pem`
  - 権限：ディレクトリ `0700`、ファイル `0600`（更新時は差分比較して最小更新）
- **環境ファイル**
  - `/etc/signage/events.env`（**0600**、更新前に `.bak.<epoch>` を自動バックアップ）
  - 内容例：

    ```dotenv
    AWS_IOT_ENDPOINT=<from metrics.env>
    EVENTS_THING_NAME=<DEVICE_ID>
    EVENTS_CERT_PATH=/etc/signage/events-certs/<DEVICE_ID>/cert.pem
    EVENTS_KEY_PATH=/etc/signage/events-certs/<DEVICE_ID>/private.key
    EVENTS_CA_PATH=/etc/signage/events-certs/<DEVICE_ID>/AmazonRootCA1.pem
    ```

- **systemd（任意）**
  - `call-button.service` が存在すれば `daemon-reload` → `restart`（失敗してもスクリプトは継続）

> 処理の流れ

1. **前提読み込み**：`signage.env` から `DEVICE_ID`、`metrics.env` から `IOT_ENDPOINT` を取得（未定義ならエラー終了）。  
2. **証明書検査**：`/tmp/events-certs/` に **3 ファイル**が存在するかチェック。  
3. **安全配置**：`/etc/signage/events-certs/<DEVICE_ID>/` を `install -d -m700` で作成し、各ファイルを `-m600` でインストール（`cmp -s` による差分更新）。  
4. **環境ファイル生成**：テンポラリに書き出してから `install -m600 -T` で原子的に置換。既存がある場合は `.bak.<epoch>` を保存。  
5. **サービス反映（任意）**：`call-button.service` が稼働していれば **daemon-reload + restart**。  
6. **完了ログ**：`DEVICE_ID` を出力して終了。

!!! note "注意"
    - `セキュリティ`：秘密鍵は `0600` で配置されます。所有者/権限が緩んでいないか必ず確認してください。
    - `入力の前提`：`/tmp/events-certs/` は本スクリプト実行前に確実に配布してください（名称固定：`cert.pem`, `private.key`, `AmazonRootCA1.pem`）。
    - `冪等性`：同一内容の再投入時は差分なしとしてスキップします（`cmp -s` / `diff -q`）。
    - `サービス依存`：`call-button.service` が無い環境でも安全に実行可能です（存在チェックあり）。
